// Generated by CoffeeScript 1.7.1
var __modulo = function(a, b) { return (a % b + +b) % b; };

(function() {
  var d3, d3po;
  d3 = null;
  if (typeof require === 'function' && define.amd) {
    d3 = require("d3");
  } else {
    d3 = window.d3;
  }
  d3po = {
    version: "0.2",
    chartcount: 0,
    curr_chart: null,
    css: "svg { font: 10px sans-serif; }\n.axis path { fill: none; stroke: #333; }\n.axis line { fill: none; stroke: #999; stroke-dasharray: 2,2;\n.label { color: black; }'",
    util: {
      transform: function(transf, elem) {
        var k, trans, v;
        trans = d3.transform(elem);
        for (k in transf) {
          v = transf[k];
          trans[k] = v;
        }
        return trans.toString();
      }
    },
    shapes: ['circle', 'cross', 'triangle-up', 'triangle-down', 'diamond', 'square'],
    colors: ['red', 'blue', 'cyan', 'green', 'orange', 'black', 'purple'],
    counter: function() {
      var counts, r;
      counts = {};
      return r = {
        get: function(key) {
          return counts[key];
        },
        inc: function(key) {
          return counts[key] = counts[key] + 1 || 0;
        }
      };
    }
  };
  d3po.randomScatter = function(points) {
    var f, i, _i, _ref, _results;
    if (points == null) {
      points = 10;
    }
    f = function(i) {
      return {
        x: d3.random.normal,
        y: d3.random.normal,
        size: Math.random,
        shape: d3po.shapes[__modulo(i, d3po.shapes.length)],
        fill: d3po.colors[__modulo(i, d3po.colors.length)],
        alpha: Math.min(1, 0.5 + Math.random())
      };
    };
    _results = [];
    for (i = _i = 0, _ref = points - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(f(i));
    }
    return _results;
  };
  d3po.randomLine = function(points) {
    var i, x, y, _i, _ref, _results;
    if (points == null) {
      points = 15;
    }
    x = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = points - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(d3.random.normal()());
      }
      return _results;
    })();
    y = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = points - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(d3.random.normal()());
      }
      return _results;
    })();
    x.sort(function(a, b) {
      return a - b;
    });
    console.log(x, y);
    _results = [];
    for (i = _i = 0, _ref = points - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        return {
          x: x[i],
          y: y[i]
        };
      })());
    }
    return _results;
  };
  d3po.randomBoxes = function(boxes) {
    var f, i, _i, _ref, _results;
    if (boxes == null) {
      boxes = 20;
    }
    f = function(i) {
      return {
        x: Math.random(),
        y: Math.random(),
        w: 100 * Math.max(0.1, d3.random.normal(1)()),
        h: 100 * Math.max(0.1, d3.random.normal(1)()),
        fill: colors[__modulo(i, colors.length)],
        stroke: colors[(i + 3) % colors.length],
        alpha: Math.min(1, 0.5 + Math.random())
      };
    };
    _results = [];
    for (i = _i = 0, _ref = boxes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(f(i));
    }
    return _results;
  };
  d3po.randomBoxGrid = function(rows, cols) {
    var d, i, j, _i, _results;
    if (rows == null) {
      rows = 10;
    }
    if (cols == null) {
      cols = 10;
    }
    d = function(i, j) {
      var r, w;
      w = Math.random;
      return r = {
        x: i,
        y: j,
        w: w,
        h: w,
        fill: d3po.colors[__modulo(i, d3po.colos.length)],
        stroke: colors[(i + 3) % colors.length],
        alpha: Math.min(1, 0.5 + Math.random())
      };
    };
    _results = [];
    for (j = _i = 1; 1 <= cols ? _i <= cols : _i >= cols; j = 1 <= cols ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (i = _j = 1; 1 <= rows ? _j <= rows : _j >= rows; i = 1 <= rows ? ++_j : --_j) {
          _results1.push(d(i, j));
        }
        return _results1;
      })());
    }
    return _results;
  };
  d3po.chart = function(opts) {
    var chart_height, chart_width, chartarea, d3poStyle, defaults, defs, getsetter, getsetter_fields, k, my, padding, props, svg, update_viewport, v, _i, _len;
    if (opts == null) {
      opts = {};
    }
    defaults = {
      height: 600,
      width: 600,
      margin: {
        top: 40,
        right: 40,
        bottom: 40,
        left: 40
      },
      name: "chart_" + d3po.chartcount,
      target: "body",
      xlim: [0, 1],
      ylim: [0, 1],
      background: "#eee",
      axis: true,
      axis_opts: {
        aspect: null,
        x_label: null,
        y_label: null,
        tick_size: 4
      },
      padding: "normal",
      grid: true,
      grid_opts: {},
      zoom: false,
      zoom_opts: {},
      tooltips: true,
      tooltips_opts: {},
      hotkeys: true,
      conrols: true
    };
    for (k in defaults) {
      v = defaults[k];
      (opts[k] != null) || (opts[k] = v);
    }
    if (d3.select('#d3po_style').empty()) {
      d3poStyle = document.createElement("style");
      d3poStyle.id = "d3po_style";
      d3poStyle.type = "text/css";
      d3poStyle.innerHTML = d3po.css;
      document.getElementsByTagName("head")[0].appendChild(d3poStyle);
    }
    d3po.chartcount += 1;
    chart_width = opts.width - opts.margin.left - opts.margin.right;
    chart_height = opts.height - opts.margin.top - opts.margin.bottom;
    svg = d3.select(opts.target).append("svg").attr({
      width: opts.width,
      height: opts.height,
      id: opts.name
    });
    defs = svg.append("defs");
    defs.append("clipPath").attr({
      id: "chartarea_clip_" + opts.name
    }).append("rect").attr({
      x: 0,
      y: 0,
      width: chart_width,
      height: chart_height
    });
    svg.append("rect").attr({
      x: opts.margin.left,
      y: opts.margin.top,
      width: chart_width,
      height: chart_height
    }).style({
      fill: opts.background
    });
    chartarea = svg.append("g").attr({
      id: "chartarea",
      "clip-path": "url(#chartarea_clip_" + opts.name + ")",
      transform: d3po.util.transform({
        translate: [opts.margin.left, opts.margin.top]
      })
    });
    chartarea.append("rect").attr({
      width: chart_width,
      height: chart_height,
      opacity: 0
    });
    padding = (function() {
      switch (false) {
        case opts.padding !== "none":
          return 0;
        case opts.padding !== "tight":
          return 0.01;
        default:
          return 0.05;
      }
    })();
    my = function() {
      return this;
    };
    props = {
      svg: svg,
      chart_width: chart_width,
      chart_height: chart_height,
      xscale: d3.scale.linear().domain([0, 1]).range([0, chart_width]),
      yscale: d3.scale.linear().domain([0, 1]).range([chart_height, 0]),
      opts: opts,
      counter: d3po.counter(),
      lines: d3po.chart.lines,
      axis: d3po.chart.axis,
      chartarea: chartarea,
      xlim: opts.xlim,
      ylim: opts.ylim,
      data_xlim: [0, 1],
      data_ylim: [0, 1],
      padding: padding,
      dispatch: d3.dispatch("update", "reset", "mouseover", "mouseout")
    };
    for (k in props) {
      v = props[k];
      my[k] = v;
    }
    update_viewport = function() {
      var aspect, data_height, data_width, tmp, xlim, ylim;
      xlim = my.data_xlim;
      ylim = my.data_ylim;
      data_width = my.data_xlim[1] - my.data_xlim[0];
      data_height = my.data_ylim[1] - my.data_ylim[0];
      aspect = 1;
      if (opts.axis_opts && opts.axis_opts.aspect) {
        if (chart_opts.axis_opts.aspect === "equal") {
          if (data_width > data_height) {
            tmp = data_width * opts.height / opts.width;
            ylim[0] = ylim[0] - (tmp - data_height) / 2;
            ylim[1] = ylim[1] + (tmp - data_height) / 2;
            data_height = tmp;
          } else {
            tmp = data_height * pts.width / opts.height;
            xlim[0] = xlim[0] - (tmp - data_width) / 2;
            xlim[1] = xlim[1] + (tmp - data_width) / 2;
            data_width = tmp;
          }
        }
      }
      my.xscale.domain([my.data_xlim[0] - my.padding * data_width, my.data_xlim[1] + my.padding * data_width]);
      my.yscale.domain([my.data_ylim[0] - my.padding * data_height, my.data_ylim[1] + my.padding * data_height]);
      if (my.zoom) {
        my.zoom.x(my.xscale).y(my.yscale);
      }
      if (my.xAxis) {
        my.svg.select('.x.axis').call(my.xAxis);
      }
      if (my.yAxis) {
        my.svg.select('.y.axis').call(my.yAxis);
      }
      return my.dispatch.update();
    };
    my.dispatch.on("reset." + opts.name, update_viewport);
    opts.axis && my.axis();
    getsetter_fields = ["height", "width"];
    getsetter = function(field) {
      return function(v) {
        if (v != null) {
          this.opts[field] = v;
        } else {
          return this.opts[field];
        }
        return my;
      };
    };
    for (_i = 0, _len = getsetter_fields.length; _i < _len; _i++) {
      k = getsetter_fields[_i];
      my[k] = getsetter(k);
    }
    return my;
  };
  d3po.chart.axis = function(opts) {
    var k, v, x_axis, x_g, y_axis, y_g, _ref;
    if (opts == null) {
      opts = {};
    }
    _ref = this.opts.axis_opts;
    for (k in _ref) {
      v = _ref[k];
      (opts != null ? opts[k] : void 0) || (opts[k] = this.opts.axis_opts[k]);
    }
    x_axis = d3.svg.axis().scale(this.xscale).orient("bottom").tickSize(-this.chart_height);
    y_axis = d3.svg.axis().scale(this.yscale).orient("left").tickSize(-this.chart_width);
    x_g = this.svg.insert("g", "#chartarea").attr({
      transform: d3po.util.transform({
        translate: [this.opts.margin.left, this.opts.margin.top + this.chart_height]
      }, null),
      "class": "x axis"
    }).call(x_axis);
    y_g = this.svg.insert("g", "#chartarea").attr({
      transform: d3po.util.transform({
        translate: [this.opts.margin.left, this.opts.margin.top]
      }, null),
      "class": "y axis"
    }).call(y_axis);
    if (opts.x_label) {
      x_g.append("text").attr({
        "class": "x label",
        "text-anchor": "middle",
        transform: d3po.util.transform({
          translate: [this.chart_width / 2, 25]
        }, this)
      }).text(opts.x_label);
    }
    if (opts.y_label) {
      y_g.append("text").attr({
        "class": "y label",
        "text-anchor": "middle",
        transform: d3po.util.transform({
          translate: [-25, this.chart_height / 2],
          rotate: -90
        }, this)
      }).text(opts.y_label);
    }
    this.x_axis = x_axis;
    return this.y_axis = y_axis;
  };
  d3po.chart.lines = function(data, line_opts) {
    var defaults, id, k, line_g, line_p, lines_this, v, xExtent, yExtent;
    if (line_opts == null) {
      line_opts = {};
    }
    console.log(data[data.length - 1]);
    defaults = {
      color: "black",
      stroke_width: 1,
      extend_edges: false
    };
    for (k in defaults) {
      v = defaults[k];
      (line_opts[k] != null) || (line_opts[k] = v);
    }
    id = "line_" + this.counter.inc("line");
    line_p = this.chartarea.append("g").attr({
      id: id
    }).append("path").data(data);
    lines_this = this;
    line_g = d3.svg.line().x(function(d) {
      return lines_this.xscale(d.x);
    }).y(function(d) {
      return lines_this.yscale(d.y);
    });
    xExtent = d3.zip(this.data_xlim, d3.extent(data, function(d) {
      return d.x;
    }));
    this.data_xlim = [d3.min(xExtent[0]), d3.max(xExtent[1])];
    yExtent = d3.zip(this.data_ylim, d3.extent(data, function(d) {
      return d.y;
    }));
    this.data_ylim = [d3.min(yExtent[0]), d3.max(yExtent[1])];
    this.update_lines = function() {
      var f, o1, o2, p1, p2, x;
      if (line_opts.extend_edges) {
        f = function(p1, p2, x) {
          var b, m;
          m = (p1.y - p2.y) / (p1.x - p2.x);
          b = p1.y - m * p1.x;
          return m * x + b;
        };
        x = lines_this.xscale.domain()[0];
        o1 = {
          x: x,
          y: f(data[0], data[1], x)
        };
        p1 = data[data.length - 2];
        p2 = data[data.length - 1];
        x = lines_this.xscale.domain()[1];
        o2 = {
          x: x,
          y: f(p1, p2, x)
        };
        data = [o1].concat(data).concat([o2]);
      }
      return line_p.attr({
        d: line_g(data),
        stroke: line_opts.color,
        "stroke-width": line_opts.stroke_width,
        fill: "none"
      });
    };
    this.dispatch.on("update." + this.name + "." + id, this.update_lines);
    this.dispatch.update();
    this.dispatch.reset();
    return null;
  };
  if (typeof define === "function" && define.amd) {
    define(d3po);
    console.log("found RequireJS and AMD, defining d3po");
  } else if (typeof exports !== "undefined" && typeof module !== "undefined") {
    module.exports = d3po;
    console.log("found CommonJS module, exporting d3po");
  } else {
    this.d3po = d3po;
    console.log("found global namespace, setting window.d3po");
  }
})();
